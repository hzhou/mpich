fncode: typesig_set(sig, dt, MPI_Aint *p_idx, MPI_Aint count)
    $if count <= 0
        return

    $local MPI_Aint idx = *p_idx

    $if HANDLE_IS_BUILTIN(dt)
        typesig_check_space(sig, idx + 1)
        $if dt == MPI_2INT
            sig->types[idx] = MPI_INT
            sig->counts[idx] = 2 * count
        $else
            sig->types[idx] = dt
            sig->counts[idx] = count
        *p_idx = idx + 1
        return
    $elif MPIR_DATATYPE_IS_PREDEFINED(dt)
        typesig_check_space(sig, idx + 2 * count)
        $my MPI_Datatype dt_a
        $(for:FLOAT,DOUBLE,LONG,SHORT)
            $if dt == MPI_$1_INT
                dt_a = MPI_$1
        $for i=0:count
            sig->types[idx] = dt_a
            sig->types[idx + 1] = MPI_INT
            sig->counts[idx] = 1
            sig->counts[idx + 1] = 1
            idx+=2
        *p_idx = idx
    $else
        $call get_dt_ptr
        $if dt_ptr->basic_type != MPI_DATATYPE_NULL
            $if HANDLE_IS_BUILTIN(dt_ptr->basic_type)
                typesig_check_space(sig, idx + 1)
                sig->types[idx] = dt_ptr->basic_type
                sig->counts[idx] = dt_ptr->n_builtin_elements * count
                *p_idx = idx + 1
                return
            $else
                typesig_set(sig, dt_ptr->basic_type, p_idx, count * dt_ptr->n_builtin_elements)
                return
        $else
            $my MPIR_Datatype_contents *cp = dt_ptr->contents
            $local int *p_ints, MPI_Aint *p_aints, MPI_Aint *p_counts, MPI_Datatype *p_types
            MPIR_Datatype_access_contents(cp, &p_ints, &p_aints, &p_counts, &p_types)
            $if cp->nr_counts == 0
                $(set:c=-)
                $call switch_combiner
            $else
                $(set:c=c)
                $call switch_combiner

    # --------------------------------
    subcode: _set_dup
        # $print "typesig_set dup"
        typesig_set(sig, p_types[0], p_idx, count)

    subcode: _set_resized
        typesig_set(sig, p_types[0], p_idx, count)

    subcode: _set_contig
        typesig_set(sig, p_types[0], p_idx, count * $(n))

    # common for vector, indexed_block
    subcode: _set_vector
        # $print "typesig_set vector count=%ld", count * $(n) * $(blkl)
        typesig_set(sig, p_types[0], p_idx, count * $(n) * $(blkl))

    subcode: _set_indexed
        $my MPI_Aint blkl_sum = 0
        $for i=0:$(n)
            blkl_sum += $(blkl:i)
        # $print "typesig_set indexed count=%ld", count * blkl_sum
        typesig_set(sig, p_types[0], p_idx, count * blkl_sum)

    subcode: _set_struct
        $my i, j: MPI_Aint
        $my MPI_Aint idx_save = *p_idx
        $my MPI_Aint idx_last = *p_idx
        $for i=0:$(n)
            typesig_set(sig, p_types[i], p_idx, $(blkl:i))
            $if idx_last > 0 && sig->types[idx_last-1] == sig->types[idx_last]
                sig->counts[idx_last-1] += sig->counts[idx_last]
                $for j=idx_last:(*p_idx - 1)
                    sig->types[j] = sig->types[j+1]
                    sig->counts[j] = sig->counts[j+1]
                (*p_idx)--
            idx_last = *p_idx
        $if count > 1
            $my MPI_Aint num = *p_idx - idx_save
            typesig_check_space(sig, idx_save + count * num)
            idx = *p_idx
            $for i=1:count
                $for j=0:num
                    sig->types[idx] = sig->types[idx_save + j]
                    sig->counts[idx] = sig->counts[idx_save + j]
                    idx++
            *p_idx = idx

    # ---------------------
    subcode: _set_subarray
        $my MPI_Aint num = 1
        $for i=0:$(n)
            num *= p_subsizes[i]
        typesig_set(sig, p_types[0], p_idx, count * num)

    subcode: _set_darray
        $my MPI_Aint num = 1
        $for i=0:$(n)
            $if p_isblk[i] == 0
                $my num_this, n_blks, n_groups: MPI_Aint
                n_blks = p_gsizes[i] / p_parg[i]
                n_groups = n_blks / p_sizes[i]
                num_this = n_groups * p_parg[i]
                $if p_prank[i] < n_blks % p_sizes[i]
                    num_this += p_prank[i]
                $if p_prank[i] == n_blks % p_sizes[i]
                    num_this += p_gsizes[i] % p_parg[i]
                num *= num_this
            $elif p_isblk[i] == 1
                num *= p_gsizes[i] / p_sizes[i]
            $else
                $if p_prank[i] < p_gsizes[i] % p_sizes[i]
                    num *= p_gsizes[i] / p_sizes[i] + 1
                $else
                    num *= p_gsizes[i] / p_sizes[i]
        typesig_set(sig, p_types[0], p_idx, count * num)

fncode: typesig_check_space(sig, MPI_Aint n)
    $if sig->n < n
        sig->n = n * 2
        sig->types = MPL_realloc(sig->types, sig->n * sizeof(MPI_Datatype), MPL_MEM_OTHER)
        sig->counts = MPL_realloc(sig->counts, sig->n * sizeof(MPI_Aint), MPL_MEM_OTHER)
