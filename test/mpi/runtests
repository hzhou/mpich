#!/usr/bin/perl
# -*- Mode: perl; -*-
#
# This script is the beginnings of a script to run a sequence of test 
# programs.  See the MPICH document for a description of the test
# strategy and requirements.
#
# Description
#   Tests are controlled by a file listing test programs; if the file is
#   a directory, then all of the programs in the directory and subdirectories
#   are run
#
#   To run a test, the following steps are executed
#   Build the executable:
#      make programname
#   Run the executable
#      mpiexec -n <np> ./programname >out 2>err
#   Check the return code (non zero is failure)
#   Check the stderr output (non empty is failure)
#   Check the stdout output (No Errors or Test passed are the only valid
#      output)
#   Remove executable, out, err files
#
# The format of a list file is
# programname number-of-processes
# If number-of-processes is missing, $np_default is used (this is 2 but can
# be overridden with -np=new-value)
#
# Special feature:
# Because these tests can take a long time to run, there is an
# option to cause the tests to stop is a "stopfile" is found.
# The stopfile can be created by a separate, watchdog process, to ensure that
# tests end at a certain time.
# The name of this file is (by default) .stoptest
# in the  top-level run directory.  The environment variable
#    MPITEST_STOPTEST
# can specify a different file name.
#
# Import the mkpath command
use strict;
use File::Path;
use File::Copy qw(move);

# Use high resolution timers
use Time::HiRes qw(gettimeofday tv_interval);

# Global variables
our %config;
set_config_default();
load_config();
load_environment();
load_commandline();
post_config();
my $verbose = $config{verbose};

my $err_count = 0;          # Number of programs that failed.
my $skip_count = 0;         # Number of programs skipped
my $total_run = 0;          # Number of programs tested
my $total_seen = 0;         # Number of programs considered for testing

my $srcdir = $config{srcdir}; # Used to set the source dir for testlist files
my $curdir = `pwd`;           # used to track the relative current directory
chomp $curdir;

#---------------------------------------------------------------------------
# Process arguments and override any defaults
#---------------------------------------------------------------------------
system "$config{mpiexec} -n 1 date" or die "Can't run mpiexec [$config{mpiexec}]!\n";

# ---- running tests ----------
# ./runtests -tests="testlist testlist.dtp"
my @alltests;
LoadTests(\@alltests, ".", $config{tests} );
RunList(\@alltests);
OutputSummary(\@alltests);

# ---- summary ----------
my $n = @alltests;
my $err_count;
foreach my $test (@alltests){
    if($test->{found_error}){
        $err_count++;
    }
}
if ($err_count) {
    print "$err_count tests failed out of $n\n";
}
else {
    print " All $n tests passed!\n";
}

# ---------------------------------------------------------------------------
# Routines
# ---------------------------------------------------------------------------
# 
sub LoadTests {
    my ($test_list, $dir, $listfiles) = @_;
    my @include_list=split /\s+/, $listfiles;
    my %history; # to prevent deadloop loading
    while (my $f = shift @include_list) {
        if (!$f or $history{$f}) {
            next;
        }
        $history{$f} = 1;

        # print "Looking in $dir/$f\n" if $verbose;
        my $listfile;
        if (-f "$dir/$f" ){
            $listfile = "$dir/$f";
        }
        elsif (-f "$srcdir/$dir/$f"){
            $listfile = "$srcdir/$dir/$f";
        }

        if (open( In, "<$listfile" )){
            if ($verbose) {
                print "Loading tests from $listfile...\n";
            }
            while (<In>) {
                s/#.*//g;
                s/\r?\n//;
                s/^\s*//;

                if (/^\s*$/) {
                    next;
                }

                if (/^include\s+(\S+)/) {
                    # include testlist.xxx
                    push @include_list, $1;
                }
                elsif (/^(\S+)/ and -d $1){
                    # directory
                    LoadTests($test_list, "$dir/$1", $listfiles);
                }
                elsif ($config{run_xfail_only} or $config{include} or $config{exclude}) {
                    if ($config{run_xfail_only}) {
                        if (!/xfail=/) {
                            next;
                        }
                        s/xfail=\S*//;
                    }
                    if ($config{include}) {
                        if (!/$config{include}/) {
                            next;
                        }
                    }
                    if ($config{exclude}) {
                        if (/$config{exclude}/) {
                            next;
                        }
                    }
                    push @$test_list, parse_testline($_);
                }
                else {
                    push @test_lines, parse_testline($_);
                }
            }
            close In;
        }
    }
}

sub parse_testline {
    my ($dir, $line) = @_;
    my %test = (line=> $line, dir=> $dir);

    # List file entries have the form:
    # program [ np [ name=value ... ] ]
    my @args = split(/\s+/,$line);
    my $programname = shift @args;
    my $np = shift @args;

    if (!$np) { $np = $config{np_default}; }
    if ($config{np_max}>0 && $np > $config{np_max}) { 
        $np = $config{np_max}; 
    }
    $test{prog} = $programname;
    $test{np} = $np;

    # Process the key=value arguments
    foreach my $a (@args) {
        if ($a =~ /([^=]+)=(.*)/) {
            my ($key,$value) = ($1, $2);
            if ($key=~/^(resultTest|init|timeLimit|arg|env|mpiexecarg|xfail|mpiversion|strict|mpix)$/) {
                if (exists $test{$key}) {
                    $test{$key}.=" $value";
                }
                else {
                    $test{$key}=$value;
                }
            }
            else {
                print STDERR "Unrecognized key $key in test line: $line\n";
            }
        }
    }
    if (exists $test{xfail} && $test{xfail} eq ""){
        print STDERR "\"xfail=\" requires an argument\n";
    }

    if (filter_mpiversion($test{mpiversion})) {
        $test{skip} = "requires MPI version $test{mpiversion}";
    }
    elsif (filter_strict($test{strict})) {
        $test{skip} = "non-strict test, strict MPI mode requested";
    }
    elsif (filter_xfail($test{xfail})) {
        $test{skip} = "xfail tests disabled: xfail=$test{xfail}";
    }
    elsif (filter_mpix($test{mpix})) {
        $test{skip} = "tests MPIX extensions, MPIX testing disabled";
    }

    return \%test;
}

sub RunList { 
    my ($test_lists) = @_;
    my $ResultTest = "";
    my $InitForRun = "";

    my $total_run = 0;
    my $err_count = 0;
    foreach my $test (@$test_lists) {
	# Check for stop file
	if (-s $config{stopfile}) {
	    # Exit because we found a stopfile
	    print STDERR "Terminating test because stopfile $config{stopfile} found\n";
	    last;
	}
        if ($verbose) {
            print "TEST: $l\n";
        }
        if($test->{skip}){
            SkippedTest($test->{prog}, $test->{np}, $test->{arg}, $test->{env}, $test->{dir}, $test->{skip});
        }
	else {
	    $total_run++;
            my ($rc, $output) = BuildMPIProgram($test);
            if ($rc == 0) {
		if ($config{run_batch}) {
		    &AddMPIProgram($test);
		}
		else {
		    &RunMPIProgram($test);
		}
	    }
	    elsif (!$test->{xfail}) {
		$err_count++;
                $test->{failed} = "Failed to build $programname; $output";
	    }
	    if (!$config{run_batch}) {
		CleanUpAfterRun( $test );
	    }
	}
    }
}

#
# Run the program.  
# ToDo: Add a way to limit the time that any particular program may run.
# The arguments are
#    name of program, number of processes, name of routine to check results
#    init for testing, timelimit, and any additional program arguments
# If the 3rd arg is not present, the a default that simply checks that the
# return status is 0 and that the output is " No Errors" is used.
sub get_test_cmd {
    my $test = shift;

    # Set a default timeout on tests (3 minutes for now)
    my $timeout = $config{timeout_default};
    if (defined($test->{timeLimit}) && $test->{timeLimit} =~ /^\d+$/) {
	$timeout = $timeLimit;
    }
    $timeout *= $config{timeout_multiplier};
    $test->{timeout} = $timeout;
    $ENV{"MPIEXEC_TIMEOUT"} = $timeout;

    my @extra_args;
    arg_ppn(\@extra_args, $test->{np});
    arg_timelimit(\@extra_args, $test->{timeout});

    my $cmd = "$config{mpiexec} $config{np_arg} $test->{np} @extra_args $test->{mpiexecargs} $config{program_wrapper} ./$test->{prog} $test->{arg}";
    return $cmd;

}

sub RunMPIProgram {
    my $test=shift;

    unlink "err";
    my $cmd = get_test_cmd($test);

    if ($verbose) {
        print "Env includes $progEnv\n";
        print "    $cmd\n";
    }
    print STDOUT "." if $config{show_progress};

    # -----------------------------
    # Save and restore the environment if necessary before running mpiexec.
    my %saveEnv;
    if ($test->{env}) {
	%saveEnv = %ENV;
	foreach my $val (split(/\s+/, $test->{env})) {
	    if ($val =~ /([^=]+)=(.*)/) {
		$ENV{$1} = $2;
	    }
	    else {
		print STDERR "Environment variable/value $val not in a=b form\n";
	    }
	}
    }
    my $start_time = gettimeofday();
    open ( my $MPIOUT, "$cmd 2>&1 |" ) || die "Could not run ./$programname\n";
    if ($test->{env}) {
	%ENV = %saveEnv;
    }

    # -----------------------------
    if ($test->{ResultTest}) {
	# Read and process the output
        my %testsubs = (
            TestStatus => \&TestStatus,
            TestStatusNoErrors => \&TestStatusNoErrors,
            TestErrFatal => \&TestErrFatal,
        );
        if ($testsubs{$ResultTest} ) {
            $testsubs{$ResultTest}->( $MPIOUT, $test );
        }
        else {
            $found_error = 1;
            $inline = "Unknown resultTest: $ResultTest"
        }
    }
    else {
        TestDefault( $MPIOUT, $test);
    }
    my $end_time = gettimeofday();
    $runtime = $end_time - $start_time;
    $test->{runtime} = $runtime;
    print STDOUT "Runtime: $runtime\n" if $verbose;

    if ($test->{found_error}) {
        &RunTestFailed($test);
    }
    else { 
        &RunTestPassed($test);
    }
}

# 
# Return value is 0 on success, non zero on failure
sub BuildMPIProgram {
    my ($test) = @_;
    my $programname = $test->{prog};
    my $rc = 0;
    if (! -x $programname) {
        $test->{need_remove} = 1;
    }
    my $cmd = "make $programname";
    if ($verbose){
        print STDERR "making $programname\n";
        print "    $cmd ...\n";
    }
    my $output = `$cmd 2>&1`;
    $rc = $?;
    if ($rc > 255) { $rc >>= 8; }
    if (! -x $programname) {
	print STDERR "Failed to build $programname; $output\n";
        $rc = 1;
    }
    if($rc==0){
        $test->{ready_to_run} = 1;
    }
    return ($rc, $output);
}

sub CleanUpAfterRun {
    my $test = shift;
    my $programname = $test->{prog};
    
    # Check for that this program has exited.  If it is still running,
    # issue a warning and leave the application.  Of course, this
    # check is complicated by the lack of a standard access to the 
    # running processes for this user in Unix.
    my @stillRunning = &FindRunning( $programname );

    if ($#stillRunning > -1) {
	print STDERR "Some programs ($programname) may still be running:\npids = ";
	for (my $i=0; $i <= $#stillRunning; $i++ ) {
	    print STDERR $stillRunning[$i] . " ";
	}
	print STDERR "\n";
	# Remind the user that the executable remains; we leave it around
	# to allow the programmer to debug the running program, for which
	# the executable is needed.
	print STDERR "The executable ($programname) will not be removed.\n";
    }
    else {
	if ($test->{need_remove} && $config{clean_programs}) {
	    unlink $programname, "$programname.o";
	}
        undef $test->{need_remove};
    }
}

# ----------------------------------------------------------------------------
sub FindRunning { 
    my $programname = $_[0];
    my @pids = ();

    my $logname = $ENV{'USER'};
    my $pidloc = 1;
    my $rc = open PSFD, "ps auxw -U $logname 2>&1 |";

    if ($rc == 0) { 
	$rc = open PSFD, "ps -fu $logname 2>&1 |";
    }
    if ($rc == 0) {
	print STDERR "Could not execute ps command\n";
	return @pids;
    }

    while (<PSFD>) {
	if (/$programname/) {
	    my @fields = split(/\s+/);
	    my $pid = $fields[$pidloc];
	    # Check that we've found a numeric pid
	    if ($pid =~ /^\d+$/) {
		$pids[$#pids + 1] = $pid;
	    }
	}
    }
    close PSFD;

    return @pids;
}
# ----------------------------------------------------------------------------
#
sub TestDefault {
    my ($MPIOUT, $test) = @_;
    my $found_noerror = 0;
    my $found_error = 0;
    my $inline = "";
    while (<$MPIOUT>) {
        print STDOUT $_ if $verbose;
        # Skip FORTRAN STOP
        if (/FORTRAN STOP/) { next; }
        $inline .= $_;
        if (/^\s*No [Ee]rrors\s*$/ && $found_noerror == 0) {
            $found_noerror = 1;
        }
        if (! /^\s*No [Ee]rrors\s*$/ && !/^\s*Test Passed\s*$/ && !/requesting checkpoint\s*$/ && !/checkpoint completed\s*$/) {
            print STDERR "Unexpected output in $programname: $_";
            if (!$found_error) {
                $found_error = 1;
                $err_count ++;
            }
        }
    }
    if ($found_noerror == 0) {
        print STDERR "Program $programname exited without No Errors\n";
        if (!$found_error) {
            $found_error = 1;
            $err_count ++;
        }
    }
    my $rc = close ( $MPIOUT );
    if ($rc == 0) {
        # Only generate a message if we think that the program
        # passed the test.
        if (!$found_error) {
            my $run_status = $?;
            my $signal_num = $run_status & 127;
            if ($run_status > 255) { $run_status >>= 8; }
            print STDERR "Program $programname exited with non-zero status $run_status\n";
            if ($signal_num != 0) {
                print STDERR "Program $programname exited with signal $signal_num\n";
            }
            $found_error = 1;
            $err_count ++;
        }
    }
}
# ----------------------------------------------------------------------------
#
# TestStatus is a special test that reports success *only* when the 
# status return is NONZERO
sub TestStatus {
    my ($MPIOUT, $test) = @_;
    my $found_error = 0;
    my $inline = "";
    while (<$MPIOUT>) {
	#print STDOUT $_ if $verbose;
	# Skip FORTRAN STOP
	if (/FORTRAN STOP/) { next; }
	$inline .= $_;
	# ANY output is an error. We have the following output
	# exception for the Hydra process manager.
	if (/=*/) { last; }
	if (! /^\s*$/) {
	    print STDERR "Unexpected output in $programname: $_";
	    if (!$found_error) {
		$found_error = 1;
		$err_count ++;
	    }
	}
    }
    my $rc = close ( MPIOUT );
    if ($rc == 0) {
	my $run_status = $?;
	my $signal_num = $run_status & 127;
	if ($run_status > 255) { $run_status >>= 8; }
    }
    else {
	# This test *requires* non-zero return codes
        if (!$found_error) {
	    $found_error = 1;
	    $err_count ++;
        }
	$inline .= "$config{mpiexec} returned a zero status but the program returned a nonzero status\n";
    }
    $test->{found_error} = $found_error;
    $test->{inline} = $inline;
}
# ----------------------------------------------------------------------------
#
# TestStatusNoErrors is like TestStatus except that it also checks for " No Errors"
# This is useful for fault tolerance tests where mpiexec returns a non-zero status
# because of a failed process, but still outputs " No Errors" when the correct
# behavior is detected.
sub TestStatusNoErrors {
    my ($MPIOUT, $test) = @_;
    my $found_error = 0;
    my $found_noerror = 0;

    my $inline = "";
    while (<MPIOUT>) {
	print STDOUT $_ if $verbose;
	# Skip FORTRAN STOP
	if (/FORTRAN STOP/) { next; }
	$inline .= $_;
	if (/^\s*No [Ee]rrors\s*$/ && $found_noerror == 0) {
	    $found_noerror = 1;
	}
	if (! /^\s*No [Ee]rrors\s*$/ && !/^\s*Test Passed\s*$/) {
	    print STDERR "Unexpected output in $test->{prog}: $_";
	    if (!$found_error) {
		$found_error = 1;
		$err_count ++;
	    }
	}
    }
    if ($found_noerror == 0) {
	print STDERR "Program $programname exited without No Errors\n";
	if (!$found_error) {
	    $found_error = 1;
	    $err_count ++;
	}
    }
    my $rc = close ( MPIOUT );
    if ($rc == 0) {
	my $run_status = $?;
	my $signal_num = $run_status & 127;
	if ($run_status > 255) { $run_status >>= 8; }
    }
    else {
	# This test *requires* non-zero return codes
        if (!$found_error) {
	    $found_error = 1;
	    $err_count ++;
        }
	$inline .= "$config{mpiexec} returned a zero status but the program required a non-zero status\n";
    }
    $test->{found_error} = $found_error;
    $test->{inline} = $inline;
}
#
# TestErrFatal is a special test that reports success *only* when the 
# status return is NONZERO; it ignores error messages
sub TestErrFatal {
    my ($MPIOUT, $test) = @_;
    my $found_error = 0;
    my $inline = "";
    while (<$MPIOUT>) {
	#print STDOUT $_ if $verbose;
	# Skip FORTRAN STOP
	if (/FORTRAN STOP/) { next; }
	$inline .= $_;
	# ALL output is allowed.
    }
    my $rc = close ( MPIOUT );
    if ($rc == 0) {
	my $run_status = $?;
	my $signal_num = $run_status & 127;
	if ($run_status > 255) { $run_status >>= 8; }
    }
    else {
	# This test *requires* non-zero return codes
	if (!$found_error) {
	    $found_error = 1;
	    $err_count ++;
	}
	$inline .= "$config{mpiexec} returned a zero status but the program returned a nonzero status\n";
    }
    $test->{found_error} = $found_error;
    $test->{inline} = $inline;
}

# ----------------------------------------------------------------------------
# Output routines:
#  RunPreMsg( programname, np, workdir ) - Call before running a program
#  RunTestFailed, RunTestPassed - Call after test
#  RunPostMsg               - Call at end of each test
#
sub OutputSummary {
    if ($config->{xmlfile}) {
        dump_xml(\@alltests, $config->{xmlfile});
    }

}

sub dump_xml {
    my ($alltests, $xmlfile)   = @_;
    my $xmlfullfile = $xmlfile;
    if (! ($xmlfile =~ /^\//)) {
        $xmlfullfile = "$curdir/$xmlfile";
    }
    open( XMLOUT, ">$xmlfile" ) || die "Cannot open $xmlfile\n";
    my $date = `date "+%Y-%m-%d-%H-%M"`;
    $date =~ s/\r?\n//;
    # MPISOURCE can be used to describe the source of MPI for this
    # test.
    my $newline = "\r\n";
    print XMLOUT "<?xml version='1.0' ?>$newline";
    print XMLOUT "<?xml-stylesheet href=\"TestResults.xsl\" type=\"text/xsl\" ?>$newline";
    print XMLOUT "<MPITESTRESULTS>$newline";
    print XMLOUT "<DATE>$date</DATE>$newline";
    print XMLOUT "<MPISOURCE>$config{MPI_SOURCE}</MPISOURCE>$newline";
    foreach $test (@$alltests) {
	print XMLOUT "<MPITEST>$newline<NAME>$test->{prog}</NAME>$newline";
	print XMLOUT "<NP>$test->{np}</NP>$newline";
	print XMLOUT "<WORKDIR>$test->{dir}</WORKDIR>$newline";
        if ($test->{skipped}){
        }
        elsif (!$test->{found_error}){
            print XMLOUT "<STATUS>pass</STATUS>$newline";
        }
        else{
            my $xout = $test->{output};
            # basic escapes that wreck the XML output
            $xout =~ s/</\*AMP\*lt;/g;
            $xout =~ s/>/\*AMP\*gt;/g;
            $xout =~ s/&/\*AMP\*amp;/g;
            $xout =~ s/\*AMP\*/&/g;
            # TODO: Also capture any non-printing characters (XML doesn't like them
            # either).
            print XMLOUT "<STATUS>fail</STATUS>$newline";
            print XMLOUT "<TESTDIFF>$newline$xout</TESTDIFF>$newline";
        }
        print XMLOUT "<TIME>$test->{runtime}</TIME>$newline";
	print XMLOUT "</MPITEST>$newline";
    }
    if (!$config{noxmlclose} ){
        print XMLOUT "</MPITESTRESULTS>$newline";
    }
    close XMLOUT; 
    print "XML formatted results in $xmlfullfile\n";
}

sub dump_tap {
    my ($alltests, $tapfile)   = @_;
    my $tapfullfile = $tapfile;
    if (! ($tapfile =~ /^\//)) {
        $tapfullfile = "$curdir/$tapfile";
    }
    open( TAPOUT, ">$tapfile" ) || die "Cannot open $tapfile\n";
    my $i=0;
    foreach $test (@$alltests) {
        if ($test->{skipped}){
            print TAPOUT "ok $i - $test->{dir}/$test->{prog} $test->{np}  # SKIP $test->{skipped}\n";
        }
        elsif (!$test->{found_error}){
            print TAPOUT "ok $i - $test->{dir}/$test->{prog} $test->{np} # time=$test->{runtime}\n";
        }
        else{
            print TAPOUT "not ok $i - $test->{dir}/$test->{prog} $test->{np}$test->{xfail} # time=$test->{runtime}\n";
            my $xout = $test->{output};
            print TAPOUT "  ---\n";
            print TAPOUT "  Directory: $test->{dir}\n";
            print TAPOUT "  File: $test->{prog}\n";
            print TAPOUT "  Num-procs: $test->{np}\n";
            print TAPOUT "  Timeout: $test->{timeout}\n";
            print TAPOUT "  Date: \"" . localtime() . "\"\n";
            print TAPOUT "  ...\n";
            # Alternative to the "Output:" YAML block literal above.  Do not put any
            # spaces before the '#', this causes some TAP parsers (including Perl's
            # TAP::Parser) to treat the line as "unknown" instead of a proper
            # comment.
            print TAPOUT "## Test output (expected 'No Errors'):\n";
            foreach my $line (split m/\r?\n/, $test->{output}) {
                chomp $line;
                print TAPOUT "## $line\n";
            }
        }
        $i++;
    }
    my $n = @$alltests;
    print TAPOUT "1..$n\n";
    close TAPOUT; 
    print "TAP formatted results in $tapfullfile\n";
}

sub dump_junit {
    my ($alltests, $junitfile)   = @_;
    my $junitfullfile = $junitfile;
    if (! ($junitfile =~ /^\//)) {
        $junitfullfile = "$curdir/$junitfile";
    }

    my $total_run = @$alltests;
    my ($err_count, $skip_count);
    foreach my $test (@$alltests){
        if ($test->{skipped}){
            $skip_count ++;
        }
        elsif ($test->{found_error})
            $err_count ++;
        }
    }

    open( JUNITOUT, ">$junitfile" ) || die "Cannot open $junitfile\n";
    my $date = `date "+%Y-%m-%d-%H-%M"`;
    $date =~ s/\r?\n//;
    print $JUNITOUT"<testsuites>\n";
    print $JUNITOUT"  <testsuite failures=\"$err_count\"\n";
    print $JUNITOUT"             errors=\"0\"\n";
    print $JUNITOUT"             skipped=\"$skip_count\"\n";
    print $JUNITOUT"             tests=\"$total_run\"\n";
    print $JUNITOUT"             date=\"${date}\"\n";
    print $JUNITOUT"             name=\"summary_junit_xml\">\n";
    my $i=0;
    foreach $test (@$alltests) {
        print JUNITOUT "    <testcase name=\"$i - $test->{dir}/$test->{prog} $test->{np} $test->{arg} $test->{env}\" time=\"$test->{runtime}\">\n";

        print JUNITOUT "    </testcase>\n";
        if ($test->{skipped} ){
            print JUNITOUT "    <testcase name=\"$i - $test->{dir}/$test->{prog} $test->{np} $test->{arg} $test->{env}\">\n";
            print JUNITOUT "      <skipped type=\"TodoTestSkipped\">\n";
            print JUNITOUT "             message=\"$test->{skip}\"><![CDATA[ok $i - $test->{dir}/$test->{prog} $test->{np}  # SKIP $test->{skipped}]]></skipped>\n";
            print JUNITOUT "    </testcase>\n";
        }
        elsif (!$test->{found_error}){
            print JUNITOUT "    <testcase name=\"$i - $test->{dir}/$test->{prog} $test->{np} $test->{arg} $test->{env}\" time=\"$test->{runtime}\"></testcase>\n";
        }
        else{
            my $testtag = "failure";
            if ($test->{xfail}) {
                $testtag = "skipped";
            }
            print JUNITOUT "      <$testtag type=\"TestFailed\"\n";
            print JUNITOUT "               message=\"not ok $i - $test->{dir}/$test->{prog} $test->{np}$test->{xfail}\"><![CDATA[";
            print JUNITOUT "not ok $i - $test->{dir}/$test->{prog} $test->{np}$test->{xfail}\n";
            print JUNITOUT "  ---\n";
            print JUNITOUT "  Directory: $test->{dir}\n";
            print JUNITOUT "  File: $test->{prog}\n";
            print JUNITOUT "  Num-procs: $test->{np}\n";
            print JUNITOUT "  Timeout: $test->{timeout}\n";
            print JUNITOUT "  Date: \"" . localtime() . "\"\n";
            print JUNITOUT "  ...\n";
            # Alternative to the "Output:" YAML block literal above.  Do not put any
            # spaces before the '#', this causes some JUNIT parsers (including Perl's
            # JUNIT::Parser) to treat the line as "unknown" instead of a proper
            # comment.
            print JUNITOUT "## Test output (expected 'No Errors'):\n";
            foreach my $line (split m/\r?\n/, $test->{output}) {
                chomp $line;
                print JUNITOUT "## $line\n";
            }
            print JUNITOUT "    ]]></$testtag>\n";
        }
        $i++;
    }
    print JUNITOUT "    <system-out></system-out>\n";
    print JUNITOUT "    <system-err></system-err>\n";
    print JUNITOUT "  </testsuite>\n";
    print JUNITOUT "</testsuites>\n";
    close JUNITOUT;

    print "JUNIT formatted results in $junitfullfile\n";
}

# ----------------------------------------------------------------------------
# Alternate init routines
sub InitQuickTimeout {
    $ENV{"MPIEXEC_TIMEOUT"} = 10;
}

# ---- config ------------------------------------------------------
# loads runtests.config into %config
sub load_config {
    my $config_dir = ".";
    if ($0=~/(.*)\//){
        $config_dir = $1;
    }
    if (-f "$config_dir/runtests.config"){
        if (open In, "$config_dir/runtests.config") {
            load_config_In();
            close In;
        }
    }
}

sub load_config_In {
    while (<In>) {
        if (/^\s*(\w+)\s*=\s*(.+)/) {
            $config{$1} = $2;
        }
    }
}

# ---- default ----
sub set_config_default {
    $config{tests} = "testlist";
    $config{srcdir} = ".";

    $config{mpiexec} = "mpiexec";

    $config{np_arg} = "-n";     # Name of argument to specify the number of processes
    $config{np_default} = 2;    # Default number of processes to use
    $config{np_max}     = -1;   # Maximum number of processes to use (overrides any

    # PPN support
    # ppn_max is the maximum number of processes per node.  -1 means ignore.
    # ppn_arg is the argument to use to mpiexec - format is "string%d"; e.g.,
    # "-ppn %d"
    $config{ppn_arg}  = '';
    $config{ppn_max}  = -1;

    $config{timeout_default} = 180;
    $config{timeout_multiplier} = 1.0;

    # (batch run: i.e., run them together, then test output, 
    # rather than build/run/check for each test)
    $config{run_batch} = 0;     # Set to true to batch the execution of the tests
    $config{batch_dir} = ".";   # Set to the directory into which to run the examples

    $config{verbose} = 0;
    $config{show_progress} = 0;

    my $pwd = `pwd`; chomp $pwd;
    $config{"stopfile"} = "$pwd/.stoptest";

    $config{clean_programs} = 1;
}

sub post_config {
    if ($config{mpiversion}=~/(\d+)\.(\d+)/) {
        $config{MPIMajorVersion} = $1;
        $config{MPIMinorVersion} = $2;
    }
    if ($config{xmlfile}){
        open_XMLOUT($config{xmlfile});
    }
    if ($config{tapfile}){
        open_TAPOUT($config{tapfile});
    }
    if ($config{junitfile}){
        open_JUNITOUT($config{junitfile});
    }
    foreach my $k ("run_strict", "run_mpix", "run_xfail", "run_batch") {
        if ($config{$k} && $config{$k} =~/^(no|false)$/i) {
            $config{$k} = undef;
        }
    }
}

# ---- environment ----
our %env_vars = (
    MPI_SOURCE => "MPI_SOURCE",
    MPITEST_MPIVERSION => "mpiversion",
    MPITEST_PPNARG => "ppn_arg",
    MPITEST_PPNMAX => "ppn_max",
    MPITEST_TIMEOUT => "timeout_default",
    MPITEST_TIMEOUT_MULTIPLIER => "timeout_multiplier",
    MPITEST_TIMELIMITARG => "timeout_arg", # e.g. "-t %d" for Cray aprun
    MPITEST_BATCH => "run_batch",
    MPITEST_BATCHDIR => "batchdir",
    MPITEST_STOPTEST => "stopfile",
    #   MPITEST_PROGRAM_WRAPPER (Value is added after -np but before test
    #                            executable.  Tools like valgrind may be inserted
    #                            this way.)
    MPITEST_PROGRAM_WRAPPER => "program_wrapper",
    VERBOSE => "verbose",
    V => "verbose",
    RUNTESTS_VERBOSE => "verbose",
    RUNTESTS_SHOWPROGRESS => "show_progress",
    # Define this to leave the XML output file open to receive additional data
    NOXMLCLOSE => "noxmlclose",
);

sub load_environment {
    while (my ($k,$v) = each %env_vars) {
        if (defined $ENV{$k} ){
            $config{$v} = $ENV{$k};
        }
    }
}

# ---- command line ----
our %cmdline_vars = (
    nparg => "np_arg",
    np => "np_default",
    maxnp => "np_max",
    ppnarg => "ppn_arg",
    ppn => "ppn_max",
    batch => "run_batch",
    batchdir => "batch_dir",
    timelimitarg => "timeout_arg",
    verbose => 1,
    showprogress => "show_progress",
    noxmlclose => 1,
);

sub load_commandline {
    foreach my $a (@ARGV) {
        if ($a=~/--?help/) {
            print STDERR "runtests [-tests=testfile] [-np=nprocesses] \
            [-maxnp=max-nprocesses] [-srcdir=location-of-tests] \
            [-ppn=max-proc-per-node] [-ppnarg=string] \
            [-timelimitarg=string] [-mpiversion=major.minor] \
            [-xmlfile=filename ] [-tapfile=filename ] \
            [-junitfile=filename ] [-noxmlclose] \
            [-verbose] [-showprogress] [-batch] 
            [-dir=execute_in_dir]\n";
            exit(1);
        }
        elsif ($a=~/--?dir=(.*)/) {
            print "---- [$1] ----\n";
            chdir $1 or die "Can't chdir $1\n";
        }
        elsif ($a =~/--?(\w+)=(.*)/){
            my ($k, $v) = ($1, $2);
            if ($cmdline_vars{$k}) {
                if ($cmdline_vars{$k} ne 1){
                    $k = $cmdline_vars{$k};
                }
                $config{$k} = $v;
            }
            else{
                warn "Unrecognized command line option [$a]\n";
        }
        elsif ($a =~/--?([\w\-]+)$/) {
            my $k = $1;
            $k=~s/-/_/g;
            $config{$k} = 1;
        }
        else {
            die "Unrecognized command line argument [$a]\n";
        }
    }
}

# ---- arg routines: add options to @$arglist ----
# Handle the ppn (processes per node) option.
sub arg_ppn {
    my ($arglist, $np) = @_;
    if ($config{ppn_arg} && $config{ppn_max} > 0) {
	my ($ppnargs, $nn) = ($config{ppn_arg}, $config{ppn_max});
	# Some systems require setting the number of processes per node
	# no greater than the total number of processes (e.g., aprun on Cray)
	if ($nn > $np) { $nn = $np; }

	$ppnargs =~ s/\%d/$nn/;
	push @$arglist, $ppnargs;
    }
}

# Handle the timelimit option.
sub arg_timelimit {
    my ($arglist, $timeout) = @_;
    if ($config{timeout_arg} ne "" && $timeout> 0) {
	my $t= $config{timeout_arg};
	$t=~ s/\%d/$timeout/;
	push @$arglist, $t;
    }
}

# -- filters: skip tests if return 1 ------------------
sub filter_mpiversion {
    my ($version_required) = @_;
    if (!$version_required) {
        return 0;
    }
    if ($config{MPIMajorVersion} eq "unknown" or $config{MPIMinorVersion} eq "unknown"){
        return 0;
    }
    my ($major, $minor) = split /\./, $version_required;
    if ($major > $config{MPIMajorVersion}) {
        return 1;
    }
    if ($major == $config{MPIMajorVersion} && $minor > $config{MPIMinorVersion} ){
        return 1;
    }
    return 0;
}

sub filter_strict {
    my ($strict_ok) = @_;
    # skip `strict=false` in strict mode
    if (lc($strict_ok) eq "false" && $config{run_strict}){
        return 1;
    }
    return 0;
}

sub filter_xfail {
    my ($xfail) = @_;
    if ($config{run_strict}) {
        return 0;
    }
    if ($xfail && !$config{run_xfail}) {
        return 1;
    }
    return 0;
}

sub filter_mpix {
    my ($mpix_required) = @_;
    if (lc($mpix_required) eq "true" && !$config{run_mpix}) {
        return 1;
    }
    return 0;
}
